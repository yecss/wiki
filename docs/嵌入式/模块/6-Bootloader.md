## ä»‹ç»

### ç³»ç»Ÿè‡ªå¸¦çš„Bootloader

**ç³»ç»Ÿè‡ªå¸¦çš„ Bootloader** åˆ™æ˜¯ STM32 èŠ¯ç‰‡å‚å®¶ï¼ˆST å…¬å¸ï¼‰åœ¨å‡ºå‚æ—¶ **å›ºåŒ–åœ¨ç‰‡å†… ROMï¼ˆç³»ç»Ÿå­˜å‚¨åŒº System Memoryï¼‰** çš„ä¸€æ®µç¨‹åºï¼Œä¸ä¼šè¢«æ“¦é™¤ã€‚

å®ƒçš„ä¸»è¦åŠŸèƒ½æ˜¯ï¼š
 ğŸ‘‰ åœ¨èŠ¯ç‰‡æ²¡æœ‰ç”¨æˆ·ç¨‹åºï¼ˆæˆ–è€…ç”¨æˆ·å¼ºåˆ¶è¿›å…¥ Boot æ¨¡å¼ï¼‰æ—¶ï¼Œæä¾›ä¸€ç§â€œä¸‹è½½/çƒ§å½•æ–°ç¨‹åºâ€çš„æ–¹å¼ã€‚

æ¢å¥è¯è¯´ï¼Œå®ƒå°±æ˜¯ å®˜æ–¹æä¾›çš„â€œåº”æ€¥çƒ§å½•å™¨â€ã€‚
 å½“ä½ æ²¡æ³•ç”¨ SWD/JTAG çƒ§å½•å™¨æ—¶ï¼Œè¿˜å¯ä»¥é€šè¿‡è¿™ä¸ª Bootloaderï¼ŒæŠŠç¨‹åºä» ä¸²å£ / USB / CAN / IÂ²C / SPI ç­‰æ¥å£ä¸‹è½½è¿› Flashã€‚

### å·¥ä½œåŸç†

1. **ä¸Šç”µ/å¤ä½å**ï¼ŒèŠ¯ç‰‡ä¼šæ ¹æ® **BOOT å¼•è„šçŠ¶æ€** å†³å®šä»å“ªé‡Œå¯åŠ¨ï¼š
   - BOOT0=0 â†’ ä» **ä¸» Flash** å¯åŠ¨ï¼ˆç”¨æˆ·ç¨‹åºï¼‰ã€‚
   - BOOT0=1 â†’ ä» **ç³»ç»Ÿå­˜å‚¨åŒºï¼ˆSystem Memoryï¼‰** å¯åŠ¨ï¼Œä¹Ÿå°±æ˜¯è¿è¡Œ **ST å†…ç½® Bootloader**ã€‚
2. **è¿›å…¥ç³»ç»Ÿ Bootloader** åï¼š
   - Bootloader ä¼šåˆå§‹åŒ–å¯¹åº”å¤–è®¾ï¼ˆæ¯”å¦‚ USART1ï¼‰ã€‚
   - ç­‰å¾…ä¸Šä½æœºï¼ˆæ¯”å¦‚ ST çš„ Flash Loader å·¥å…·ï¼Œæˆ– STM32CubeProgrammerï¼‰é€šè¿‡åè®®å‘é€ä¸‹è½½å‘½ä»¤ã€‚
   - æ”¶åˆ°å‘½ä»¤åï¼Œå°±èƒ½æŠŠæ–°ç¨‹åºå†™å…¥ Flashã€‚

## ä¸²å£

**STM32 ä¸²å£ + DMA + ç©ºé—²ä¸­æ–­ + ç¼“å†²åŒº** çš„ç»å…¸æ–¹æ¡ˆ

> è¿™ä¸ªæ–¹æ¡ˆåœ¨ é«˜æ•ˆç‡ã€ä¸ä¸¢æ•°æ® çš„åœºæ™¯ä¸‹éå¸¸å¸¸è§ï¼Œæ¯”å¦‚ç”¨ ESP8266/ESP32 ATæŒ‡ä»¤ æˆ– å¤§æ‰¹é‡ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ã€‚

2. å·¥ä½œæµç¨‹

1. **åˆå§‹åŒ–DMAå¾ªç¯æ¥æ”¶**
   - è®¾ç½® DMA é€šé“ï¼ŒæŠŠä¸²å£çš„ `DRå¯„å­˜å™¨` ç»‘å®šåˆ°ä¸€å— **å¾ªç¯ç¼“å†²åŒº**ã€‚
   - é…ç½® DMA é•¿åº¦ï¼Œæ¯”å¦‚ 256å­—èŠ‚ã€‚
   - å¯åŠ¨ DMA å¾ªç¯æ¨¡å¼ï¼Œè¿™æ · DMA ä¼šä¸€ç›´æŠŠæ”¶åˆ°çš„æ•°æ®å­˜åˆ°ç¼“å†²åŒºã€‚
2. **å¼€å¯ä¸²å£ç©ºé—²ä¸­æ–­**
   - å½“ UART å‘ç°ä¸€æ®µæ—¶é—´æ²¡æœ‰æ•°æ®è¾“å…¥ï¼Œå°±è§¦å‘ **ç©ºé—²ä¸­æ–­**ã€‚
   - åœ¨ç©ºé—²ä¸­æ–­é‡Œï¼Œå¯ä»¥è®¤ä¸ºâ€œè¿™ä¸€å¸§æ•°æ®åˆ°å¤´äº†â€ã€‚
3. **è®¡ç®—æ¥æ”¶é•¿åº¦**
   - åœ¨ç©ºé—²ä¸­æ–­ ISR ä¸­ï¼š
     - å…ˆæ¸…é™¤ç©ºé—²ä¸­æ–­æ ‡å¿—ã€‚
     - å…³é—­ DMAã€‚
     - æ ¹æ® `æ¥æ”¶ç¼“å†²åŒºé•¿åº¦ - DMAå½“å‰çš„CNDTRå¯„å­˜å™¨å€¼` ç®—å‡ºæœ¬æ¬¡æ¥æ”¶çš„æ•°æ®é•¿åº¦ã€‚
     - æŠŠæ•°æ®æ‹·è´åˆ°ç”¨æˆ·å¤„ç†ç¼“å†²åŒºã€‚
     - é‡æ–°å¼€å¯ DMAã€‚
4. **ç”¨æˆ·å¤„ç†æ•°æ®**
   - åº”ç”¨å±‚å°±èƒ½æ‹¿åˆ°ä¸€å¸§å®Œæ•´çš„æ•°æ®ï¼Œè¿›è¡Œåè®®è§£æï¼Œæ¯”å¦‚ MQTT æ¶ˆæ¯ã€ATæŒ‡ä»¤ã€Modbus å¸§ã€‚

## ABåˆ†åŒºè§„åˆ’

ZET6 512KB ä¸€é¡µ2KBï¼Œä¸€å…±256é¡µ 0~255

BåŒº 40K 0~19

AåŒº 80K 20~63

## keilè®¾ç½®è·³è½¬

![image-20250905132207931](./images/image-20250905132207931.png)

ç„¶å

![image-20250905132318043](./images/image-20250905132318043.png)

## åˆ†åŒºè·³è½¬çš„ä¸¤å¤§ä»»åŠ¡

1. è®¾ç½®spï¼ŒAåŒºçš„èµ·å§‹åœ°å€ç»™åˆ°sp
2. è®¾ç½®pcï¼ŒAåŒºçš„èµ·å§‹ä½ç½®+4ç»™åˆ°pc

è¡¥å……ï¼šæŠŠæˆ‘ä»¬åœ¨BåŒºç”¨åˆ°çš„å¤–è®¾ï¼Œå¯„å­˜å™¨reset

## åˆ†åŒºè·³è½¬çš„è¿‡ç¨‹

AåŒºè®¾ç½®å‘é‡è¡¨çš„åœ°å€å’Œä¸‹è½½çš„åœ°å€ï¼ŒBåŒºåˆ¤æ–­ä¹‹åï¼Œè·³è½¬åˆ°AåŒºçš„åœ°å€

è·³è½¬åAåŒºè¦å¯åŠ¨ä¸­æ–­

```
__enable_irq();   // ç¡®ä¿ä¸­æ–­æ‰“å¼€
```

172.20.10.2

## ç»†èŠ‚é—®ç­”

1. **è°å°†OTA_flagå˜æˆå¯¹å‹¾ï¼Ÿ**
   AåŒº
2. **ä»€ä¹ˆæ—¶å€™å°†OTA_flagå˜æˆå¯¹å‹¾ï¼Ÿ**
   AåŒºä¸‹è½½å®Œæ¯•ä¹‹å
3. **OTAæ—¶ï¼Œæœ€æ–°ç‰ˆæœ¬çš„ç¨‹åºæ–‡ä»¶ä¸‹è½½åˆ°å“ªï¼Ÿ**
   åˆ†ç‰‡ä¸‹è½½ï¼Œ[256], W25Q64ä¸­
4. **OTAæ—¶ï¼Œæœ€æ–°ç‰ˆæœ¬çš„ç¨‹åºæ–‡ä»¶å¦‚ä½•ä¸‹è½½ï¼Ÿä¸‹è½½å¤šå°‘ï¼Ÿ**
   æœåŠ¡å™¨ä¸‹å‘å‘Šè¯‰æˆ‘ä»¬ä¸Šä¼ çš„æ–°ç‰ˆæœ¬ç¨‹åºçš„å¤§å°ï¼Œå­—èŠ‚æ•°
5. **ä¸‹è½½å¤šå°‘è¿™ä¸ªå˜é‡ç”¨ä¸ç”¨ä¿å­˜ï¼Ÿ**
   ç”¨ï¼Œä¿å­˜åˆ°24C02
6. **å‘ç”ŸOTAäº‹ä»¶æ—¶ï¼ŒBåŒºå¦‚ä½•æ›´æ–°AåŒºï¼Ÿ**
   æ ¹æ®ä¿å­˜åœ¨24C02ä¸­çš„ä¸‹è½½é‡ï¼Œæ‹¿æ•°æ®ï¼Œå†™åˆ°AåŒº

## XmodemåŸºæœ¬æµç¨‹

> Xmodem 128å­—èŠ‚åŒ…æ ‡å‡†é•¿åº¦ä¸º 133ï¼ˆSOH+åŒ…å·+åŒ…å·åç +128å­—èŠ‚æ•°æ®+2å­—èŠ‚CRCï¼‰ï¼Œä½†å®é™…ä¼ è¾“å¯èƒ½ä¼šæœ‰åå·®ï¼Œå»ºè®®å…ˆæ‰“å° `datalen` å’Œ `data[0]`ï¼Œç¡®è®¤æ˜¯å¦æ”¶åˆ°å®Œæ•´åŒ…ã€‚

![image-20250904103343278](./images/image-20250904103343278.png)

## CRCæ ¡éªŒ

åœ¨çº¿æ ¡éªŒå·¥å…·ï¼šhttp://www.ip33.com/crc.html

### å®ç°ä»£ç 

```c
uint16_t Xmodem_CRC16(uint8_t *data, uint16_t datalen)
{
    uint16_t crc = 0x0000;
    uint16_t i;

    while (datalen--) {
        crc ^= ((uint16_t)(*data++) << 8); // é€šè¿‡å¼‚æˆ–ï¼ˆ^=ï¼‰æŠŠæ–°å­—èŠ‚æ··å…¥å¯„å­˜å™¨ï¼Œå°†å­—èŠ‚æ”¾åˆ°é«˜ 8 ä½ï¼Œæ–°æ¥çš„å­—èŠ‚è¦æ”¾åœ¨ å·¦è¾¹çš„é«˜ 8 æ ¼ï¼ˆbit15~bit8ï¼‰ï¼Œè¿™æ ·æ¯æ¬¡å·¦ç§»æ—¶ï¼Œå®ƒä¼šæ…¢æ…¢è¿›å…¥æœ€é«˜ä½ï¼Œé€ä½è®¡ç®—ã€‚å¦‚æœæ”¾åœ¨ä½ 8 ä½ï¼Œé‚£å®ƒæ ¹æœ¬èµ°ä¸åˆ°æœ€é«˜ä½ï¼ŒCRC å°±ç®—é”™äº†
        for (i = 0; i < 8; i++) {
            if (crc & 0x8000) {
                crc = (crc << 1) ^ 0x1021;
            } else {
                crc = (crc << 1);
            }
        }
    }
    return crc;
}

```

## Keilç”Ÿæˆbinæ ¼å¼æ–‡ä»¶

![image-20250904120054809](./images/image-20250904120054809.png)

```
"D:\Keil_v5\ARM\ARMCC\bin\fromelf.exe" --bin "Objects\Project.axf" --output "Objects\Project.bin"
```

ç„¶åç¼–è¯‘å°±ä¼šè‡ªåŠ¨ç”Ÿæˆbinæ–‡ä»¶

## ä¸²å£IAPå…³é”®ä»£ç 

```c
if (BootStaFlag & IAP_XMODEM_D_FLAG)
  {
    // æ¥æ”¶æ•°æ®åŒ…ï¼ˆXmodem 128 bytesï¼‰
    if ((datalen == 133) && (data[0] == 0x01))
    {
      BootStaFlag &= ~IAP_XMODEM_C_FLAG; // æ¸…æ‰Cæ¨¡å¼æ ‡å¿—

      // è®¡ç®— CRC
      UpdateA.XmodemCRC = Xmodem_CRC16(&data[3], 128);

      // æ ¡éªŒ CRC
      if (UpdateA.XmodemCRC == (data[131] * 256 + data[132]))
      {
        uint16_t packet_index = UpdateA.XmodemNB % (STM32_PAGE_SIZE / 128); // ä¸€é¡µå¯ä»¥æ”¾16ä¸ªåŒ…
        // ç›´æ¥è®¡ç®—å½“å‰åŒ…åœ¨é¡µå†…çš„åç§»ä½ç½®
        uint32_t buff_offset = packet_index * 128;

        // æ‹·è´æ•°æ®åˆ°ç¼“å†²åŒº
        memcpy(&UpdateA.Updatebuff[buff_offset], &data[3], 128);
        UpdateA.XmodemNB++; // åŒ…è®¡æ•°é€’å¢

        // æ¯æ»¡ä¸€é¡µå†™å…¥ Flash (å…³é”®ä¿®å¤ï¼šåœ°å€è®¡ç®—å’Œå­—æ•°é‡)
        if ((UpdateA.XmodemNB % (STM32_PAGE_SIZE / 128)) == 0)
        {
          uint32_t page_index = (UpdateA.XmodemNB / (STM32_PAGE_SIZE / 128)) - 1;
          uint32_t flash_addr = STM32_A_SADDR + (page_index * STM32_PAGE_SIZE);

          // ä¼ å…¥å­—æ•°é‡ = é¡µå¤§å°(2048) / 4
          Flash_WriteWords(flash_addr,
                           (uint32_t *)UpdateA.Updatebuff,
                           STM32_PAGE_SIZE / 4); // 2048/4=512 words
        }
        printf("\x06"); // ACK
      }
      else
      {
        printf("\x15"); // NAK
      }
    }

    // æ¥æ”¶ç»“æŸæ ‡å¿—ï¼ˆEOTï¼‰
    if ((datalen == 1) && (data[0] == 0x04))
    {
      printf("\x06"); // ACK

      // å†™å…¥å‰©ä½™ä¸è¶³ä¸€é¡µçš„æ•°æ®
      uint16_t packets_remain = UpdateA.XmodemNB % (STM32_PAGE_SIZE / 128);
      if (packets_remain != 0)
      {
        uint32_t page_index = UpdateA.XmodemNB / (STM32_PAGE_SIZE / 128);
        uint32_t flash_addr = STM32_A_SADDR + (page_index * STM32_PAGE_SIZE);
        uint32_t byte_count = packets_remain * 128;

        // ä¼ å…¥å­—æ•°é‡ = å­—èŠ‚æ•° / 4
        Flash_WriteWords(flash_addr,
                         (uint32_t *)UpdateA.Updatebuff,
                         byte_count / 4);
      }

      BootStaFlag &= ~IAP_XMODEM_D_FLAG;
      Delay_ms(100);
      NVIC_SystemReset(); // ç³»ç»Ÿå¤ä½
    }
  }
```

æ³¨æ„ç‚¹ï¼ŒFLASHå†™å…¥æ˜¯æŒ‰å­—çš„å•ä½å†™å…¥çš„ã€‚

ä¸€æ¬¡å†™32ä½ï¼Œ4ä¸ªå­—èŠ‚ï¼Œå†™å¤šå°‘æ¬¡ï¼Œå°±æ˜¯2048/4

## è®¾ç½®ç‰ˆæœ¬å·

æ ¼å¼ï¼š

```
VER-1.0.0-2025/09/04-15:04
```

![image-20250904150647526](./images/image-20250904150647526.png)

ç‚¹è¿™ä¸ªç²˜è´´

## flashåŒºåˆ«

![image-20250904153653791](./images/image-20250904153653791.png)

##  æŠŠå¤–éƒ¨ W25Q128 ä¸Šçš„ç¨‹åºåˆ·åˆ° STM32 å†…éƒ¨ Flash
